{"meta":{"title":"Newoahil's Blog","subtitle":"千言万语汇做一句Factos","description":"","author":"Newoahil","url":"http://example.com","root":"/"},"pages":[],"posts":[{"title":"鸡鸭识别器","slug":"鸡鸭识别器","date":"2023-05-05T14:54:52.000Z","updated":"2023-05-05T15:15:05.371Z","comments":true,"path":"2023/05/05/鸡鸭识别器/","link":"","permalink":"http://example.com/2023/05/05/%E9%B8%A1%E9%B8%AD%E8%AF%86%E5%88%AB%E5%99%A8/","excerpt":"","text":"基于PaddlePaddle深度学习框架对CIFAR10数据集训练卷积神经网络实现鸡鸭识别的程序。首先，你需要导入必要的库：import paddleimport paddle.fluid as fluidimport numpy as npimport osfrom PIL import Image 然后，你需要定义网络模型：def convolutional_neural_network(image): conv1 = fluid.layers.conv2d(input=image, num_filters=32, filter_size=3, stride=1) bn1 = fluid.layers.batch_norm(conv1, act=&#x27;relu&#x27;) pool1 = fluid.layers.pool2d(input=bn1, pool_size=2, pool_type=&#x27;max&#x27;, pool_stride=2) conv2 = fluid.layers.conv2d(input=pool1, num_filters=64, filter_size=3, stride=1) bn2 = fluid.layers.batch_norm(conv2, act=&#x27;relu&#x27;) pool2 = fluid.layers.pool2d(input=bn2, pool_size=2, pool_type=&#x27;max&#x27;, pool_stride=2) conv3 = fluid.layers.conv2d(input=pool2, num_filters=128, filter_size=3, stride=1) bn3 = fluid.layers.batch_norm(conv3, act=&#x27;relu&#x27;) pool3 = fluid.layers.pool2d(input=bn3, pool_size=2, pool_type=&#x27;max&#x27;, pool_stride=2) fc1 = fluid.layers.fc(input=pool3, size=256, act=&quot;relu&quot;) fc2 = fluid.layers.fc(input=fc1, size=2, act=&quot;softmax&quot;) return fc2 其中，convolutional_neural_network 函数是卷积神经网络模型的主函数，根据输入图像进行卷积、池化、全连接等操作，最后输出预测结果，这里的输出为两个元素的一维向量，每个元素分别对应着鸡和鸭的概率，我们将通过比较这两个概率之间的大小来判断图像的内容是鸡还是鸭。接下来，定义输入数据和标签以及数据的预处理方式：def load_image(file): im = Image.open(file) im = im.resize((32, 32), Image.ANTIALIAS) im = np.array(im).astype(np.float32) im = im.transpose((2, 0, 1)) im = im / 255.0 return imdef load_data(file): img = load_image(file) return img load_image 函数用于读入图像文件，并将其转换为大小为32x32的RGB三通道矩阵，load_data 函数用于读入数据集并进行预处理。 接下来，我们需要定义训练过程中的一些超参数：BATCH_SIZE = 64EPOCH_NUM = 10 其中，BATCH_SIZE 表示每次读入的数据批量大小，EPOCH_NUM 表示训练的轮数。然后，定义PaddlePaddle框架自带的数据输入方式并准备训练：# 定义输入image = fluid.layers.data(name=&#x27;image&#x27;, shape=[3, 32, 32], dtype=&#x27;float32&#x27;)label = fluid.layers.data(name=&#x27;label&#x27;, shape=[1], dtype=&#x27;int64&#x27;)# 获取网络模型predict = convolutional_neural_network(image)# 获取损失函数cost = fluid.layers.cross_entropy(input=predict, label=label)avg_cost = fluid.layers.mean(cost)# 获取准确率accuracy = fluid.layers.accuracy(input=predict, label=label)# 定义优化方法optimizer = fluid.optimizer.AdamOptimizer(learning_rate=0.001)opts = optimizer.minimize(avg_cost)# 创建执行器place = fluid.CUDAPlace(0)exe = fluid.Executor(place)exe.run(fluid.default_startup_program())# 开始训练train_reader = paddle.batch(paddle.reader.shuffle(paddle.dataset.cifar.train10(), buf_size=50000), batch_size=BATCH_SIZE)test_reader = paddle.batch(paddle.reader.shuffle(paddle.dataset.cifar.test10(), buf_size=10000), batch_size=BATCH_SIZE)for epoch_id in range(EPOCH_NUM): for batch_id, data in enumerate(train_reader()): image_data, label_data = data image_data = np.array(image_data).astype(&#x27;float32&#x27;) label_data = np.array(label_data).astype(&#x27;int64&#x27;).reshape(-1, 1) outs = exe.run(feed=&#123;&#x27;image&#x27;: image_data, &#x27;label&#x27;: label_data&#125;, fetch_list=[avg_cost, accuracy]) out_cost = np.array(outs[0]) out_accuracy = np.array(outs[1]) if batch_id % 200 == 0: print(&#x27;Epoch: %d, Batch: %d, Loss: %f, Accuracy: %f&#x27; % (epoch_id, batch_id, out_cost, out_accuracy)) if batch_id &gt; 0 and batch_id % 400 == 0: # 保存训练模型 filename = &#x27;model-%d-%d&#x27; % (epoch_id, batch_id) fluid.io.save_inference_model(dirname=&#x27;./tmp/&#x27; + filename, feeded_var_names=[&#x27;image&#x27;], target_vars=[predict], executor=exe) 其中，train_reader 和 test_reader 函数分别定义训练集和测试集的输入方式。exe.run 中，feed 参数用于提供输入的数据和标签，fetch_list 参数用于获取训练的损失值和准确率值。通过不断迭代训练样本，可以逐渐提升模型的性能。每迭代完成一个阶段，都可以保存当前的训练模型，以便在后续使用。最后，你需要根据模型进行预测：# 保存最终的训练模型fluid.io.save_inference_model(dirname=&#x27;./model&#x27;, feeded_var_names=[&#x27;image&#x27;], target_vars=[predict], executor=exe)# 加载模型infer_program, feeded_var_names, target_vars = fluid.io.load_inference_model(dirname=&#x27;./model&#x27;, executor=exe)# 预测结果img_path = &#x27;test.jpg&#x27;img = load_data(img_path)results = exe.run(program=infer_program, feed=&#123;feeded_var_names[0]: img[np.newaxis]&#125;, fetch_list=target_vars)result = np.argmax(results[0])if result == 0: print(&#x27;This is a chicken.&#x27;)else: print(&#x27;This is a duck.&#x27;) 这里，我们将预测图片路径 img_path = &#39;test.jpg&#39; 传入 load_data 函数中预处理，然后将数据喂入经过训练的网络模型 infer_program 中进行预测，通过比较鸡和鸭的概率大小，我们可以得到预测结果并输出。","categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://example.com/categories/ChatGPT/"}],"tags":[{"name":"PaddlePaddle","slug":"PaddlePaddle","permalink":"http://example.com/tags/PaddlePaddle/"}]},{"title":"OS计算方法集合","slug":"OS计算方法集合","date":"2023-04-26T12:09:34.000Z","updated":"2023-04-26T11:47:02.864Z","comments":true,"path":"2023/04/26/OS计算方法集合/","link":"","permalink":"http://example.com/2023/04/26/OS%E8%AE%A1%E7%AE%97%E6%96%B9%E6%B3%95%E9%9B%86%E5%90%88/","excerpt":"","text":"多道编程时CPU利用率求法例题 假定我们有3个程序，每个程序花费80%的时间进行I/O，20%的时间使用CPU，每个程序启动时间和其需要使用进行计算的分钟数 如下，不考虑进程切换时间： 程序编号 启动时间 需要CPU时间（分钟） 1 &emsp;00:00 &emsp;3.5 2 &emsp;00:10 &emsp;2 3 &emsp;00:15 &emsp;1.5 请问，在多线程/进程环境下，系统的总响应时间为 解析0-10分钟的时候，只有一个进程1在运行。单进程CPU占有率是20%，所以这10分钟内，进程1消耗了2分钟的CPU。进程2是0，进程3也是0然后在10-15分钟内，有两个进程在运行（1和2），双进程的CPU利用率是36%，所以，这五分钟内，CPU一共利用了1.8分钟，平均分给每个进程，是0.9分钟。此时，进程1已经占用了CPU 2.9分钟，还需要0.6分钟，这时候有三个进程在运行，所有总的CPU时间需要1.8分钟。三进程的CPU利用率是48.8%，所以总共需要1.8/0.488=3.69分钟。这时，**进程1已经3.5分钟的CPu利用时间利用完了**。此时还剩下2和3号进程在运行。2号进程还需要0.5分钟，所以0.5×2/0.36=2.78，此时2号进程的2分钟CPU时间也利用完了。3号进程还需要0.4分钟的CPU利用时间。0.4/0.2 = 2 结论 根据本题的初始效率(CPU 20% I/O 80%) 只有一个进程的时候，CPU利用率肯定是20%。 两个进程的时候：CPu利用率是：20% + (1-20%)*20% = 36% 三个进程是：36% + (1-36%)*20% = 48.8%其它的依次类推。 保证不发生死锁例题1 系统中有4个并发进程，每个进程都需要2个A资源，则系统最少应提供（ ）个A资源才能保证不会发生死锁 解析1系统提供资源数 = 1个A资源*4个进程+1个A资源 = 5 例题2 系统有11台打印机和N个并发进程，每个进程请求3台打印机，为确保不发生死锁，N的值最大为（ ） 解析2打印机数 = 2个打印机*N个进程 + 1 = 11N = 5 结论 保证不发生死锁,即至少有一个进程能获得所有资源,即至少一个进程能获得2个A资源,其他进程获得一个A资源 处理机调度算法先到先服务算法(FCFS) 在作业调度中，算法每次从后备队列中选择最先进入该队列的一个或多个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。 最短作业优先调度算法(SJF) 作业（进程）优先调度算法是指对短作业（进程）优先调度的算法。这一算法是从后备队列中选择一个或若干个估计运行时间最短的作业，将它们调入内存运行。 轮转法调度算法(RR) 在这种算法中，系统将所有的就绪进程按到达时间的先后顺序排成一个队列，进程调度程序总是选择就绪队列中的第一个进程执行，即先来先服务原则。 作业调度性能衡量 周转时间 = 运行时间 + 等待时间 = 作业完成时刻 - 作业到达时刻 ； 等待时间 = 上一个的周转时间 - 距离上一个的到达时间 = 上一个的等待时间 + 上一个的运行时间 - 距离上一个的到达时间 带权周转时间 = 周转时间 / 服务时间（运行时间）；平均周转时间 = 作业周转总时间 / 作业个数； 平均带权周转时间 = 带权周转总时间 / 作业个数； 例题 进程 就绪时刻 CPU执行时间 P1 0 3 P2 1 1 P3 2 3 P4 3 2 使用FCFS,SJF,RR(时间片 = 1)调度算法.画出各自Gannt图(解析暂不提供),回答每种调度算法的平均周转时间和平均等待时间. 解析FCFS:平均周转时间:[3+(4 - 1)+(7 - 2)+(9 - 3)]/4 = 4.25平均等待时间:[0+(3 - 1)+(4 - 2)+(7 - 3)]/4 = 2SJF:平均周转时间:[3+(4 - 1)+(6 - 3)+(9 - 2)]/4 = 4平均等待时间:[0+(3 - 1)+(4 - 3)+(6 - 2)]/4 = 1.75RR:平均周转时间:[(2 - 1)+(7 - 3)+(8 - 0)+(9 - 2)]/4 = 4.25平均等待时间:[(3 + 2)+(0)+(2 + 2)+(2)]/4 = 2.75","categories":[{"name":"Operating-System-OS","slug":"Operating-System-OS","permalink":"http://example.com/categories/Operating-System-OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"代码高亮测试","slug":"代码高亮测试","date":"2023-04-24T12:42:02.000Z","updated":"2023-04-24T13:31:03.339Z","comments":true,"path":"2023/04/24/代码高亮测试/","link":"","permalink":"http://example.com/2023/04/24/%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%B5%8B%E8%AF%95/","excerpt":"","text":"C++#include&lt;cstdio&gt;#include&lt;iostream&gt;#include&lt;algorithm&gt;const int maxn=1050;const int maxm=20000010;int h,n,v[maxn],w[maxn],f[maxm],maxx;int main()&#123; cin&gt;&gt;h&gt;&gt;n; memset(f,0x3f,sizeof(f)); f[0]=0; for(int i=1;i&lt;=n;i++) cin&gt;&gt;v[i]&gt;&gt;w[i],maxx=max(v[i],maxx); for(int i=1;i&lt;=n;i++) &#123; for(int j=v[i];j&lt;=h+maxx;j++) f[j]=min(f[j],f[j-v[i]]+w[i]); &#125; int ans=inf; for(int i=h;i&lt;=h+maxx;i++) ans=min(ans,f[i]); cout&lt;&lt;ans&lt;&lt;endl; return 0;&#125; Javaimport java.util.Scanner;public class Main &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); double[][] M = new double[12][12]; double sum = 0, cnt = 0; char C = sc.next().charAt(0); for(int i = 0; i &lt; 12; i++) for(int j = 0; j &lt; 12; j++) &#123; M[i][j] = sc.nextDouble(); if(i &lt; j &amp;&amp; i + j &gt; 11) &#123; sum += M[i][j]; cnt++; &#125; &#125; if(C == &#x27;M&#x27;) sum = sum / cnt; System.out.printf(&quot;%.1f&quot;, sum); &#125;&#125; Javascriptconst smoothScrollToTop = () =&gt; &#123; let yTopValve = (window.pageYOffset || document.body.scrollTop || document.documentElement.scrollTop); if (yTopValve &gt; 1) &#123; window.requestAnimationFrame(smoothScrollToTop); scrollTo(0, Math.floor(yTopValve * 0.85)); &#125; else &#123; scrollTo(0, 0); &#125;&#125;;setTimeout(() =&gt; &#123; document.getElementById(&#x27;scrollbutton&#x27;).onclick = smoothScrollToTop;&#125;, 0); Pythonimport requestsimport reimport sysimport osurl = &#x27;https://twoshot.hgame.n3ko.co/&#x27;headers = &#123; &#x27;Content-Type&#x27;: &#x27;application/x-www-form-urlencoded&#x27;, &#x27;User-Agent&#x27;: &#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&#x27;,&#125;p = requests.get(url+&#x27;random.php?times=228&#x27;, headers=headers)randnum = re.findall(r&#x27;\\d*&#x27;, p.text)[1:-2:2]firstnum = randnum[0]lastnum = randnum[227]content = os.popen(&quot;python3 ./reverse_mt_rand.py &quot; + firstnum+&#x27; &#x27;+lastnum+&#x27; 0 0&#x27;).read()q = requests.post(url+&#x27;/verify.php&#x27;, headers=headers, data=&#123;&#x27;ans&#x27;: content&#125;)print(q.text)","categories":[{"name":"Blog-Maintenance","slug":"Blog-Maintenance","permalink":"http://example.com/categories/Blog-Maintenance/"}],"tags":[{"name":"网页测试","slug":"网页测试","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5%E6%B5%8B%E8%AF%95/"}]},{"title":"第二部分_进程管理Part2","slug":"第二部分-进程管理Part2","date":"2023-04-24T12:01:49.000Z","updated":"2023-04-25T14:40:44.229Z","comments":true,"path":"2023/04/24/第二部分-进程管理Part2/","link":"","permalink":"http://example.com/2023/04/24/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86-%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86Part2/","excerpt":"","text":"竞争条件与临界区 在操作系统中，临界区是 一段程序 一个正在访问临界资源的进程由于申请I/O操作而被阻塞时 可以允许其他进程抢占处理机，但不得进入该进程的临界区 访问不同临界资源的两个进程不要求必须互斥地进入临界区","categories":[{"name":"Operating-System-OS","slug":"Operating-System-OS","permalink":"http://example.com/categories/Operating-System-OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第二部分_进程管理Part1","slug":"第二部分_进程管理Part1","date":"2023-04-24T12:00:09.000Z","updated":"2023-04-25T14:51:32.180Z","comments":true,"path":"2023/04/24/第二部分_进程管理Part1/","link":"","permalink":"http://example.com/2023/04/24/%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86_%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86Part1/","excerpt":"","text":"进程概念 并发进程指 可同时执行的进程 当一个进程处于这样的状态时, 正等待输入一批数据 ,称为阻塞态 阻塞→运行 是不可能发生的 一个进程从运行态变为就绪态 必会引起进程切换 进程自身决定 从执行状态到阻塞状态 创建进程 父进程和子进程可以并发执行 当进程采用操作fork()创建新的进程时，父进程和子进程之间共享 共享内存段 线程概念 线程的切换,可能引起进程的切换 同一进程或不同进程内的线程都可以并发执行 引入线程可提高程序并发执行的程度，可进一步提高系统效率 内核支持线程的切换都需要内核的支持 在用户空间实现线程，其最大的优点是什么？最大的缺点是什么？ 最大优点：效率。因为线程切换时，无须陷入内核。 最大缺点：一个线程被阻塞，整个进程被阻塞。 创建线程 在支持多线程的系统中，进程P创建的若干线程不能共享的是 进程P中某线程的栈指针 在同一进程的多线程之间,会被共享的有 堆 全局变量 进程状态模型(五状态)","categories":[{"name":"Operating-System-OS","slug":"Operating-System-OS","permalink":"http://example.com/categories/Operating-System-OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第一部分_概论Part2","slug":"第一部分_概论Part2","date":"2023-04-24T11:40:53.000Z","updated":"2023-04-25T14:40:26.544Z","comments":true,"path":"2023/04/24/第一部分_概论Part2/","link":"","permalink":"http://example.com/2023/04/24/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86_%E6%A6%82%E8%AE%BAPart2/","excerpt":"","text":"概念 多程序设计的目的 提高计算机资源利用率 分时系统设计的目的 提高交互性 Linux和Windows主要是用C语言来编写，有少数用于设备驱动的代码用汇编语言编写 对 多处理器系统共享物理内容 多核 非对称多处理器 对称多处理器 CPU有两种工作状态：内核态、用户态，其中属于特级权的是 内核态 管态 运行在内核态的程序是 设定计时器的值 缓冲区读写程序 中断服务程序 操作系统的主要部件或功能 处理机管理 内存管理 文件系统 输入输出管理 批处理系统、实时系统的特点 批处理系统为了提高计算机的利用率，开发者将程序、数据和其它信息一并提交给计算机中心，缺乏无交互性。 实时系统追求可靠性和即时性","categories":[{"name":"Operating-System-OS","slug":"Operating-System-OS","permalink":"http://example.com/categories/Operating-System-OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"第一部分_概论Part1","slug":"第一部分_概论Part1","date":"2023-04-24T02:18:43.000Z","updated":"2023-04-25T14:40:29.436Z","comments":true,"path":"2023/04/24/第一部分_概论Part1/","link":"","permalink":"http://example.com/2023/04/24/%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86_%E6%A6%82%E8%AE%BAPart1/","excerpt":"","text":"前导知识 内存是按 字节 编址 1KB = 1024B 硬盘是按 扇区 编址。 高级语言中int和float两种数据类型的变量占据的多大的内存 4B Cache地址映射方式中，现实中用的最多的是 组相连映射 Cache机制是基于程序执行的什么特点局部性原理 CPU中为什么要使用CACHE 内存速度慢 Intel CPU内存管理使用小端(Little Endian) 内存是CPU可直接寻址和访问的唯一大容量存储器 正确 没有操作系统(OS) 是可以的(操作系统只是方便使用计算机。) Linux中超级用户的名称是 root Linux中名称为“..“的文件是 父目录 Cache与内存的关系 比内存快 比内存小 二者的内容有关系，Cache是内存的内容的子集 属于内部中断 程序中除0 数组访问越界 调试程序中设置的断点 Window是 单用户 多任务 Linux中下列符号的含义： ~:家目录 &gt;:输出重定向 &lt;:输入重定向 | : | 左边的运行结果是 | 右边的输入条件或范围","categories":[{"name":"Operating-System-OS","slug":"Operating-System-OS","permalink":"http://example.com/categories/Operating-System-OS/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Markdown格式测试","slug":"博客Markdown格式测试","date":"2023-04-10T03:05:27.000Z","updated":"2023-04-26T11:05:32.332Z","comments":true,"path":"2023/04/10/博客Markdown格式测试/","link":"","permalink":"http://example.com/2023/04/10/%E5%8D%9A%E5%AE%A2Markdown%E6%A0%BC%E5%BC%8F%E6%B5%8B%E8%AF%95/","excerpt":"这是为了测试Hexo Markdown的效果","text":"这是为了测试Hexo Markdown的效果 多级标题(共六种) “# 一级 “## 二级“### 三级“#### 四级“##### 五级“###### 六级 Tab缩进&amp;空格 &amp; emsp; //Tab&amp; nbsp; //空格 分割线用不少于三个的’-‘创建分割线; 代码引用#include &lt;iostream&gt;using namespace std;int main()&#123; printf(&quot;using ``` start ``` end to enter the code&quot;);&#125;return 0; 斜体在两个*之间填充内容即可 加粗在内容两侧放置两个** 划除内容两边各加入两个~ 无序列表 第一项 第二项 第三项 有序列表 第一项 第二项 第三项 区块 区块中使用列表 第一项 第二项 第三项 第一项 第二项 第三项 使用”&gt;”号实现 链接bilibili 在中括号内放置自定义名称,后接括号内放链接地址 图片 与链接方法相同 在最前段添加”!”即可 键盘按键显示使用 Ctrl+Alt+Del 重启电脑 仍待补充…","categories":[{"name":"Blog-Maintenance","slug":"Blog-Maintenance","permalink":"http://example.com/categories/Blog-Maintenance/"}],"tags":[{"name":"网页测试","slug":"网页测试","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5%E6%B5%8B%E8%AF%95/"}]}],"categories":[{"name":"ChatGPT","slug":"ChatGPT","permalink":"http://example.com/categories/ChatGPT/"},{"name":"Operating-System-OS","slug":"Operating-System-OS","permalink":"http://example.com/categories/Operating-System-OS/"},{"name":"Blog-Maintenance","slug":"Blog-Maintenance","permalink":"http://example.com/categories/Blog-Maintenance/"}],"tags":[{"name":"PaddlePaddle","slug":"PaddlePaddle","permalink":"http://example.com/tags/PaddlePaddle/"},{"name":"操作系统","slug":"操作系统","permalink":"http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"网页测试","slug":"网页测试","permalink":"http://example.com/tags/%E7%BD%91%E9%A1%B5%E6%B5%8B%E8%AF%95/"}]}